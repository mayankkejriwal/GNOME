--we assume the bank has an infinite number of houses, hotels and cash. Cash denominations will not be relevant; we will only record cash as a number, rather than as 'bill counts' of 5, 10, 100 etc. 

--voluntary actions ('action_choices') can be pre-dice roll or post-dice roll. The pre-dice roll always concludes with the roll_die action, which is ordinarily invoked by the player to indicate that they are rolling the dice. We may limit the number of actions (say 3 or 4) a player may take before the roll_die has to be invoked. Similarly, for post-dice roll, the player must signal the end of their turn with the conclude_turn action (which does not really do anything, except pass the turn to the next player). Again, we may limit actions in post-dice before the turn is concluded. We will clarify the values of these limits when we release the simulator.

--If no action leads to non-zero cash for the player who rolled, bakruptcy code is invoked for that player. We will provide more details on what happens in the simulator, but the intuition is that all properties get liquidated, returned to the bank, and the player's status is set to 'lost'. 

--for taxes, we are going to follow the flat rate methodology, rather than calculating taxes as a percentage of assets

--except real estate, railroads, utilities, taxes, and 'do_nothing', other location types fall under 'action', and involve an action that may not involve any cash transfer. Such locations will have a 'perform_action' key that will reference a function (corresponding to the action to be taken). Currently, we just provide the name of that function. In the actual simulator, the function will be callable using reflections. 

--currently, each location has a start_position and end_position. By default, end_position is start_position+1, since each location only occupies one position on the board. As discussed, one of the novelties that could be injected is that the end_position could be several 'steps' out, so that a single location occupies more than one slot on the board.     

--concerning value assignments, some keys can only take a single value upon instantiation (e.g. 'player_name') and others will be sets (e.g., action_choices for pre-die roll available to a player). For most fields, it is fairly clear from the name, values or game semantics, whether the key is single- or multi-valued. In some cases, we use a double list to remove ambiguity e.g., 'full_color_sets_possessed' in 'player_states' is a list of lists, since multiple full color sets may be possessed by a player. 

--the location types (indicated by 'class') indicate what would happen when a player lands on it. For example, 'tax' class would invoke a payment from the player to the bank (not described in the schema; the simulator will lay out the action-mechanics of each location class). Programmatically, the game engine would update states and calculate permissible action choices based on the location class.    

--How we model time: each step will fall under exactly one 'phase': 'pre_die_roll' and 'post_die_roll' for one of four players. If a player executes an out-of-turn move, it has to occur (by definition) when another player is in their pre-die or post-die roll phase. Note that, currently, simultaneous actions are not allowed. So if player_2 makes an out_of_turn move during, say, player_3's pre_die_roll, player_2's move will be placed into an internally-time-stamped queue (which may also contain moves by other players) and the FIFO methodology will be used to pop from the queue and enforce the one action/time-step rule. A change in state (of a player) may only occur between two steps. 
	--This may seem complicated, but will become apparent once you see an actual game trace output by the simulator. We have to enforce non-simultaneity to avoid race conditions and have a well-defined game behavior. Players can simultaneously 'submit' moves, in which case we will arbitrarily break ties when placing the moves in the FIFO queue. So if both player_2 and player_3 simultaneously bid 500$ on a certain property (assuming an auction is going on), we would arbitrarily break the tie (using a seeded random generator for fairness), and if player_3 is in front, player_2's bid would be returned (but with the option to raise the bid, thereby ensuring fairness).   

--there are many functions that are NOT 'action choices' and will be called using reflection to calculate/update aspects relevant to gameplay. One example is 'move_player' which is not an action choice i.e. once the player rolls the dice, the game will automatically invoke move player, and updated the player's current position. Only those update functions relevant to the schema are included. 

--As promised, the rules are in natural language and correspond mostly to the standard version. We've included an annotated document on the same. We also include documents on property prices, rents, community chest, chance etc. to explain our values and verify that everything is per official rules. 

--for the actions, we do not describe the parameter space in this game schema, since there is a close connection to the actual simulator, which is still being written. When we release the simulator, the APIs will make it clear what the parameters and return values will be for each action function. In some cases, the parameters are specified e.g., the bank_cash_transaction (a common action invoked in the chance/community chest cards) would transfer the specified 'amount' from the player to the bank. 

--although we are continuing to check the game schema for possible errors as we write the simulator, we may miss something; please flag if you see something that does not make sense!  
